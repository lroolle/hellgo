#+TITLE: Readme

* ~make~ & ~new~

- ~make~:
  - Create a channel
  - Create a map with *space preallocated*
  - Create a slice with *space preallocated* or with *len != cap*
- ~new~:
  The main thing it makes easier is creating pointers to non-composite types.
  The two functions below are equivalent.
#+BEGIN_SRC go :exports both
import "fmt"

func newInt1() *int { return new(int) }

func newInt2() *int {
    var i int
    return &i
}

func main() {
    fmt.Println("-- MAKE --")
    a := make([]int, 0)
    aPtr := &a
    fmt.Println("pointer == nil :", *aPtr == nil)
    fmt.Printf("pointer value: %p\n\n", *aPtr)

    fmt.Println("-- COMPOSITE LITERAL --")
    b := []int{}
    bPtr := &b
    fmt.Println("pointer == nil :", *bPtr == nil)
    fmt.Printf("pointer value: %p\n\n", *bPtr)

    fmt.Println("-- NEW --")
    cPtr := new([]int)
    fmt.Println("pointer == nil :", *cPtr == nil)
    fmt.Printf("pointer value: %p\n\n", *cPtr)

    fmt.Println("-- VAR (not initialized) --")
    var d []int
    dPtr := &d
    fmt.Println("pointer == nil :", *dPtr == nil)
    fmt.Printf("pointer value: %p\n", *dPtr)
}
#+END_SRC

#+RESULTS:
#+begin_example
-- MAKE --
pointer == nil : false
pointer value: 0x11a8c50

-- COMPOSITE LITERAL --
pointer == nil : false
pointer value: 0x11a8c50

-- NEW --
pointer == nil : true
pointer value: 0x0

-- VAR (not initialized) --
pointer == nil : true
pointer value: 0x0
#+end_example

* Arrays & Slice

** Arrays

** Slices

#+BEGIN_SRC go :exports both
import "fmt"

func main() {
	s := []int{1, 2, 3}
	// fmt.Println(s == []int{1, 2,3}) ERROR: Slice can only be compared to nil
	fmt.Println(s == nil)
	fmt.Println(s)
}
#+END_SRC

#+RESULTS:
: false
: [1 2 3]
